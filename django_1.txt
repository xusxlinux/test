django:

在虚拟环境中先安装jango:
pip install django==3.2.12

django-admin startproject site

python manage.py runserver 0.0.0.0:5000

python manage.py startapp   创建应用
python manage.py migrate    数据库迁移

python manage.py 			列出子命令


pycharm创建django-3.2.12项目:
	需要修改的地方(配置文件setting.py):
	  数据库的连接:
	  允许浏览器访问的地址:
	  语言:
	  时区:
	
    1丶创建页面连接:
    urls.py文件:
	  path:
	  init, str
	  
	  from django.urls import path, re_path
	  
	2丶创建视图文件(views.py):
	  import django.http from HttpResponse
	
  
	3丶Django中的请求
		path_info: URL字符串
		method: 字符串, 表示HTTP去那个球方法, 常用值: GET POST
		GET: QueryDict查询字典对象, 包含get请求方式的所以数据
		POST: QueryDict查询字典对象, 包含post请求方式的所以数据(form表单使用, 专门用来提交数据)
		FILES: 类似于字典的对象, 包含所有的上传文件信息
		COOKIES: Python字典, 包含所有cookie, 键和值都为字符串
		seeion: 类似字典的对象, 表示当前的会话
		body: 字符串, 请求请求体的内容(POST或者PUT)
		scheme: 请求协议('http'/'https')
		request.get_full_path():请求的丸子路径
		request.META: 请求的元数据(消息头)
			- request.META['REMOTH_ADDR']: 客户端IP地址
			
	
	4丶无论是GET还是POST, 统一都由视图函数接收请求, 通过判断request.method区分具体的请求动作
		if request.method == 'GET':
			处理GET请求时的业务逻辑
		elif request.method == 'POST':
			处理POST请求的业务逻辑
		else:
			其他请求业务逻辑
			
			
	5丶MVC代表Model-View-Controller (模型-实体-控制器) 模式  --> MTV
	  作用: 降低模块间的耦合度(解耦)
		M 模型层 主要用于对数据库层的封装
		V 视图层 用于向用户展示结果
		C 控制   用于处理请求, 获取数据, 返回结果
	

	6丶Template
	  启用setting.py文件[TEMPLATES]的配置:
	    'DIRS': [os.path.join(BASE_DIR, 'templates')],
	
		
		能传递到模板中的数据类型:
			str   -  字符串              int   - 整形
			list  -  数组                tuple - 元组
			dict  -  字典                func  - 方法
			obj   -  类实例化的对象
			
		在模板中使用变量语法:
			- {{ 变量名 }}
			- {{ 变量名:index }}
			- {{ 变量名.key }}
			- {{ 对象.方法 }}
			- {{ 函数名 }}
			
		模板标签: - if标签
		
		模板标签: - for标签
			内置变量 - forloop:
			
			变量调用 - 点大法
			标签语法 {% 标签 %} {% 结束标签 %}
			
		模板过滤器:
			定义: 在变量输出时对变量的值进行处理
			作用: 可以通过使用 过滤器来改变变量的输出显示
			语法: {{ 变量|过滤器1:'参数值'|过滤器2:'参数值' }}
			
		模板的继承: (模板继承时, 服务器端的动态内容无法继承)
		  {% extends 'base.html' %} 
			重写: 按照父模板的效果显示
			不重写: 按照重写效果显示
			
		url反向解析:
			url反向解析是指在视图或模板中, 用path定义的名称来动态查找或计算出相应的路由:
				path(route, views, name='别名')
				path('page', views.page_view, name='page_url')
				
			根据path中的'name'=关键字参数给 url确定了一个唯一确定的名字,
			在模板或视图中, 可以通过这个名字反向推断出此url信息.
			
			在视图函数中 -> 调用django中的reverse方法进行反向解析:
			  urls.py:
				path('base_index',views.base_view, name='base_index'),
			
			  views.py
				from django.urls import reverse
				
				url = reverse('base_index')
				return HttpResponseRedirect(url)
				
				
	6丶静态文件配置
		配置静态文件的访问路径:(setting.py)
			STATIC_URL = '/static/'
		配置静态文件的存储路径 STATICFILES_DIRS
			STATICFILES_DIRS = (os.path.join(BASE_DIR, 'static'),)
			
		静态文件 - 模板
		  通过 {% static %}标签访问静态文件
			加载 static - {% load static %}
			使用静态资源 - {% static '静态资源路径' %}
			样例:
			  <img src="{% static 'image/Riven.jpg' %}">

	
	7丶分布式路由
		Django中, 主路由配置文件(urls.py)可以不处理用户具体路由, 主路由配置文件的可以做请求的分发(分布式请求处理)
		具体的请求可以由各自的应用来进行处理. 
		
			需要在setting.py中INSTALLED_APPS中添加应用名称
				注意: 
					优先查找最外层的templas的index.html
					哪个应用(music, news)"index.html"写在前面, 显示哪个应用的templates中的同名文件(index.html)
		
			Browser: -->	urls.py(根据地址分析)
				1. news应用		--> urls.py  --> views.py
				2. music应用	--> urls.py  --> views.py

		步骤 - 主路由中调用include函数
			语法: include('app名字.url模块名')
				from django.urls import path, include
			作用: 用于将当前路由转到给个应用的路由配置文件的 urlpatterns
		
		手动创建应用(music,news,app等)的配置文件urls.py
			from django.urls import path
			from . import views